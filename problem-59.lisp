(in-package :project-euler)

(defun get-problem-59-data ()
  (read-problem-n-data 59))

(defun apply-xor-code (char-1 char-2 char-3 data)
  (let ((data-copy (copy-seq data)))
    (flet ((xor (index char) (setf (elt data-copy index) (boole boole-xor (elt data-copy index) char))))
      (loop for i from 0 to (1- (length data)) do
	    (cond ((= 0 (mod i 3)) (xor i char-1))
		  ((= 1 (mod i 3)) (xor i char-2))
		  ((= 2 (mod i 3)) (xor i char-3))))
      data-copy)))

(defun text-sanity-check (text)
  (and (every #'(lambda (char) (> char 31)) text)
       (let ((char-occurances (make-array 255 :initial-element 0)))
	 (loop for code across text do (incf (elt char-occurances code)))
	 (macrolet ((frequency-lower-p (char amount) `(< (elt char-occurances (char-code ,char)) ,amount)))
	   (and (frequency-lower-p #\% 2)
		(frequency-lower-p #\~ 2)
		(frequency-lower-p #\& 2)
		(frequency-lower-p #\@ 2)
		(frequency-lower-p #\$ 2)
		(frequency-lower-p #\# 2)
		(frequency-lower-p #\! 2)
		(frequency-lower-p #\{ 2)
		(frequency-lower-p #\} 2)
		(frequency-lower-p #\> 2)
		(frequency-lower-p #\< 2))))))

(defun show-59-text-output (code)
  (let ((char-1 (char-code (elt code 0)))
	(char-2 (char-code (elt code 1)))
	(char-3 (char-code (elt code 2))))
  (format t "~{~c~}~%" (mapcar #'code-char (coerce (apply-xor-code char-1 char-2 char-3 (get-problem-59-data)) 'list)))))
(defun find-problem-59-key ()
  (let ((original-data (get-problem-59-data)))
    (loop for char-1 from (char-code #\a) to (char-code #\z) append
	 (loop for char-2 from (char-code #\a) to (char-code #\z) append
	      (loop for char-3 from (char-code #\a) to (char-code #\z)
		 when (text-sanity-check (apply-xor-code char-1 char-2 char-3 original-data))
		 collect (list char-1 char-2 char-3))))))
(defun problem-59 ()
  (let ((key (first (find-problem-59-key))))
    (reduce #'+ (apply-xor-code (first key) (second key) (third key) (get-problem-59-data)))))
