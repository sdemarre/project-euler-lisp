(in-package :project-euler)
(defmacro remainder (number divisor)
  `(second (multiple-value-list (floor ,number ,divisor))))

(defmacro top-n-digits (number num-digits)
  `(floor ,number (expt 10 (- (ceiling (log ,number 10)) ,num-digits))))

(defmacro bottom-n-digits (number num-digits)
  `(remainder ,number (expt 10 ,num-digits)))


(defun pandigital-bottom-and-top-p (number)
  (let ((bottom-string (prin1-to-string (bottom-n-digits number 9)))
	(top-string (prin1-to-string (top-n-digits number 9))))
    (and (= (length bottom-string) 9)
	 (= (length top-string) 9)
	 (equal (sort top-string #'char<) "123456789")
	 (equal (sort bottom-string #'char<) "123456789"))))

(defun pandigital-bottom-p (number)
  (let ((digits (prin1-to-string number)))
    (and (> (length digits) 8)
	 (equal (sort (subseq digits (- (length digits) 9)) #'char<) "123456789"))))
(defun pandigital-top-p (number)
  (let ((digits (prin1-to-string number)))
    (and (> (length digits) 8)
	 (equal (sort (subseq digits 0 9) #'char<) "123456789"))))

(defun problem-104 ()
  (let ((start 2479) (num-top-digits 12))
    (let ((k start) 
	  (bfkm1 (bottom-n-digits (fib start) 10)) (bfk (bottom-n-digits (fib (1+ start)) 10))
	  (tfkm1 (top-n-digits (fib start) num-top-digits)) (tfk (top-n-digits (fib (1+ start)) num-top-digits)))
      (until (and (pandigital-bottom-p bfk) (pandigital-top-p tfk))
	     (incf k)
	     (psetf bfkm1 bfk bfk (remainder (+ bfkm1 bfk) 1000000000))
	     (psetf tfkm1 tfk tfk (+ tfkm1 tfk))
	     (while (> (ceiling (log tfk 10)) num-top-digits)
	       (setf tfkm1 (round tfkm1 10) tfk (round tfk 10)))
	     (when (zerop (remainder k 1000))
	       (format t "~a~%" k)))
      (1+ k))))
